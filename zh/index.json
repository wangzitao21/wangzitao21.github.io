[{"content":"之前将家里的光猫设置为桥接模式，改用路由器拨号并关闭 IPv6 防火墙，能够顺利使用公网 IPv6 入站。\n但运营商提供的是 /56 位的动态 IPv6 前缀，每隔几天就会更换一次，使用起来不是很方便。\n以下是我尝试的几种应对措施。\nDDNS 解决动态 IP 的最好办法就是使用 DDNS，即动态 DNS 解析。以下是具体的流程。\n1 配置反向代理 首先需要安装 Nginx，并用 acme 申请域名证书。这里最好申请泛域名证书，以便使用多个三级域名。具体步骤见 [[Nginx (反向代理) 和 Acme (证书配置)]]，本文不再赘述。\n然后配置 Nginx 反向代理，步骤如下:\n以 Anki 服务为例，该服务监听 27701 端口。创建配置文件: 1 2 cd /etc/nginx/conf.d \u0026amp;\u0026amp; \\ vim /etc/nginx/conf.d/anki.conf 写入以下配置。端口号的范围是 0-65535，这里我将只监听 63001 这样的高位端口，只采用 SSL 访问。HTTP 不设置监听。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 server { listen 63001 ssl; listen [::]:63001 ssl; server_name anki.example.com; location / { proxy_pass http://127.0.0.1:27701; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_redirect off; proxy_set_header X-Real-Port $remote_port; proxy_set_header HTTP_X_FORWARDED_FOR $remote_addr; proxy_set_header X-NginX-Proxy true; proxy_set_header Accept-Encoding \u0026#34;\u0026#34;; } ssl_certificate /root/.acme.sh/example.com_ecc/fullchain.cer; ssl_certificate_key /root/.acme.sh/example.com_ecc/example.com.key; add_header Strict-Transport-Security \u0026#34;max-age=63072000\u0026#34; always; } 这样做的话，在某些设备上可能无法从 HTTP 重定向到 HTTPS，需要在域名前面手动输入 https://。\n另外，需要记得在防火墙放行 63001 端口。\n2 安装与配置 DDNS-GO 我使用 ddns-go 项目搭建，Docker 命令如下:\n1 2 3 4 5 6 docker run -d \\ --name ddns-go \\ --restart=always \\ --net=host \\ -v /home/wang/docker_data/ddns-go:/root \\ jeessy2/ddns-go 容器构建完成后，在 9876 端口就可以直接访问 ddns-go 的 Web 界面，并进行以下配置:\nDNS 服务商选择 Cloudflare。 打开 Cloudflare 首页，依次找到“管理账户” \u0026gt; “账号 API 令牌” \u0026gt; “创建令牌” \u0026gt; “编辑区域 DNS”，点击“使用模板”，然后选中自己的二级域名作为需要包括的区域。 复制生成的 Token 值，并粘贴到 DDNS-GO 的 Web 界面里。 继续在 Web 界面，勾选启用 IPv6，选择“通过网口获取”，选中对应网口，在 Domains 处填写自己需要动态解析的三级域名，然后保存上述配置即可。 在命令行尝试查询自己的三级域名 IP: 1 nslookup xxx.example.com 3 关于 DDNS 的风险 由于 DDNS 需要配置域名，并且要在域名厂商处配置 DNS 解析。原则上，建站就必须在工信部备案。\n但备案又不能使用家用设备。另外，据网上所说，运营商有时候会检测并查封 TLS 入站流量。所以使用 DDNS 可能会面临一定风险。\n规避这种风险的措施有以下几种:\n改用高位端口。常用的 80、443、8080、8443 等端口都尽量不要使用 (有的地区这些端口默认就是关闭的)。 添加域名的访问路径。比如 xxx.example.com 可以改成只有 xxx.example.com/path 才能访问，没有输入路径则返回 444 报错。 放弃公网访问，改用 VPN。使用 VPN 访问无疑是最安全的，但是这种方式一般仅限自己个人使用，分享给别人会麻烦一些。下文的 Tailscale 部分将介绍这种做法。 手动 DDNS。配置一个 SMTP 邮件服务器，定时向邮箱发送服务器当前的 IPv6。这是最粗暴的一种做法，可作为备用手段。下文将介绍这种做法。 使用 Tailscale VPN Tailscale 是一款基于 WireGuard 协议的虚拟局域网搭建工具，可以将不同地方的设备连接到一个私有的网络中。\nTailscale 的最大优势就是在两端设备都有公网 IPv6 的情况下，可以直连而不需要第三方服务器中转，因此访问速度能得到保障。\nTailscale 的安装基本没有什么难度，直接在 Download 页面正常下载，并完成安装注册流程即可。\n在所有设备都安装 Tailscale 后，可在 Admin console 页面查询到虚拟局域网内所有在线和不在线的设备。此后我们只要保证 Tailscale 后台开启，就能使用局域网域名或 IP 直接访问对应服务。\nLinux 系统可以使用以下命令查询和关闭/启用 Tailscale:\n1 2 3 4 5 6 sudo systemctl enable tailscaled sudo systemctl status tailscaled sudo systemctl restart tailscaled sudo systemctl stop tailscaled cat /lib/systemd/system/tailscaled.service Tailscale 的用法还有很多，对于我而言，目前只需要达到 VPN 访问的目的。后续有需要将持续更新。\n1 中转服务器 对于没有 IPv6 的设备，Tailscale 支持使用中转服务器。但是 Tailscale 提供的中转服务器都在国外，延迟难以得到保障。我们可以使用以下命令查询官方中转服务器延迟:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 测试中转服务器延迟 tailscale netcheck # 输出如下 Report: * Time: 2025-01-26T10:37:16.276723386Z * UDP: true * IPv4: yes, xxx.xxx.xxx.xxx:26667 * IPv6: yes, [240e:xxxx:xxxx:xxxx::c2]:57110 * MappingVariesByDestIP: false * PortMapping: * CaptivePortal: false * Nearest DERP: Tokyo * DERP latency: - tok: 130.7ms (Tokyo) - sin: 159ms (Singapore) - sfo: 160.1ms (San Francisco) - hkg: 166.8ms (Hong Kong) - lax: 167.9ms (Los Angeles) - sea: 168.2ms (Seattle) - den: 172.6ms (Denver) - ... ... 为了提高无公网 IPv6 设备的使用体验，我们也可以搭建一个中转服务器。但对于我目前的处境而言，完全没有这方面的需求，因此未作尝试。\n2 文件共享 Tailscale 只需要在 General 界面 开启“Send Files”功能，就可以在虚拟局域网内各个在线设备间传输文件。\nWindows 和 Android 系统会发送到系统的 Downloads 文件夹，Linux 系统会发送到以下目录:\n1 /var/lib/tailscale/files/账号邮箱-uid-xxxxxx 不过目前感觉该功能还是略显鸡肋，Android 每次还得专门开启 Tailscale 后才能传输。而 Windows 和 Linux 间虽然可以默认自启，但完全可以事先挂载各种共享文件夹。\n邮件定时发送 IPv6 地址 为了防止 DDNS 方法失效，我还准备了一个最粗暴的方法，即用 Python 写一个简单的脚本，定时用我的 Foxmail 邮箱向我的 Outlook 邮箱报告当前服务器的 IPv6 地址，以备在特殊情况下可以采用纯 IP 访问。\n具体步骤如下:\n首先在 Foxmail 中配置 SMTP/IMAP 服务，按照官网指示操作即可。 执行以下命令创建 Conda 环境和安装相关模块: 1 2 3 conda create -n ddns python=3.11 \u0026amp;\u0026amp; conda activate ddns pip install requests schedule 我这里编写了一个简单的 Python 脚本:\n1 vim /home/wang/shell/ddns_mail.py 写入以下内容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import smtplib from email.mime.text import MIMEText import requests import schedule import time # 邮箱配置 SMTP_SERVER = \u0026#39;smtp.qq.com\u0026#39; # SMTP 服务器地址 SMTP_PORT = 587 # SMTP 服务器端口号 EMAIL_ADDRESS = \u0026#39;xxx@foxmail.com\u0026#39; # 发送邮箱地址 EMAIL_PASSWORD = \u0026#34;xxx\u0026#34; # 邮箱应用专用密码 RECEIVER_EMAIL = \u0026#39;xxx@outlook.com\u0026#39; # 收件邮箱地址 # 获取 IPv6 地址的 API (可根据需要更换, 或从本地直接获取) IPV6_API = \u0026#39;https://api6.ipify.org\u0026#39; def get_ipv6_address(): \u0026#34;\u0026#34;\u0026#34;获取服务器的 IPv6 地址。\u0026#34;\u0026#34;\u0026#34; try: response = requests.get(IPV6_API) response.raise_for_status() # 检查请求是否成功 return response.text.strip() except requests.exceptions.RequestException as e: print(f\u0026#34;获取 IPv6 地址失败: {e}\u0026#34;) return None def send_email(ipv6_address): \u0026#34;\u0026#34;\u0026#34;发送包含 IPv6 地址的邮件。\u0026#34;\u0026#34;\u0026#34; if ipv6_address: message = MIMEText(f\u0026#34;服务器当前的 IPv6 地址是: {ipv6_address}\u0026#34;) message[\u0026#39;Subject\u0026#39;] = \u0026#39;服务器 IPv6 地址\u0026#39; message[\u0026#39;From\u0026#39;] = EMAIL_ADDRESS message[\u0026#39;To\u0026#39;] = RECEIVER_EMAIL server = None try: server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT) server.starttls() # 启用 TLS 加密 server.login(EMAIL_ADDRESS, EMAIL_PASSWORD) server.sendmail(EMAIL_ADDRESS, RECEIVER_EMAIL, message.as_string()) print(\u0026#34;邮件发送成功！\u0026#34;) except Exception as e: # 捕获更广泛的异常 print(f\u0026#34;邮件发送失败: ({type(e)}) {e}\u0026#34;) # 输出异常的类型 finally: if server: try: server.quit() except Exception as e: print(f\u0026#34;关闭连接时出现错误: ({type(e)}) {e}\u0026#34;) else: print(\u0026#34;无法发送邮件，IPv6 地址未知。\u0026#34;) def job(): \u0026#34;\u0026#34;\u0026#34;定时任务函数，获取并发送 IPv6 地址。\u0026#34;\u0026#34;\u0026#34; ipv6_address = get_ipv6_address() send_email(ipv6_address) # 设置定时任务 schedule.every().day.at(\u0026#34;20:17\u0026#34;).do(job) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;脚本已启动，将每天定时发送 IPv6 地址。\u0026#34;) while True: schedule.run_pending() time.sleep(1) 为上述脚本添加一个守护进程: 1 sudo vim /etc/systemd/system/ddns_mail.service 写入以下内容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 [Unit] Description=DDNS Mail After=network.target [Service] Type=simple User=wang WorkingDirectory=/home/wang/shell ExecStart=/home/wang/apps/miniconda3/envs/ddns/bin/python /home/wang/shell/ddns_mail.py \u0026gt;\u0026gt; /home/wang/logs/ddns_mail.log 2\u0026gt;\u0026amp;1 Restart=on-failure [Install] WantedBy=multi-user.target 启用或关闭进程服务。 1 2 3 4 5 6 sudo systemctl daemon-reload sudo systemctl enable ddns_mail.service sudo systemctl restart ddns_mail.service sudo systemctl status ddns_mail.service # 查询日志 journalctl -u ddns_mail.service 上述脚本目前能正常运行，但输出日志一直是空的，手动执行和权限问题都排查了也没能解决。具体原因暂时不想深究了，能正常使用就行。\n","permalink":"https://wangzitao21.github.io/zh/%E8%A7%A3%E5%86%B3%E5%8A%A8%E6%80%81%E5%85%AC%E7%BD%91-ipv6-%E8%AE%BF%E9%97%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","summary":"\u003cp\u003e之前将家里的光猫设置为桥接模式，改用路由器拨号并关闭 IPv6 防火墙，能够顺利使用公网 IPv6 入站。\u003c/p\u003e\n\u003cp\u003e但运营商提供的是 /56 位的动态 IPv6 前缀，每隔几天就会更换一次，使用起来不是很方便。\u003c/p\u003e","title":"解决动态公网 IPv6 访问的几种方法"},{"content":"ssh 即 Secure Shell，也就是在 shell 上增加了加密功能。我们常见的 Linux 服务器登录时都使用了 ssh。\n之前只是糊涂地使用 ssh，并没有搞清楚里面的原理和具体步骤，这次系统地做了一些梳理。\n不过本文仍旧比较简单，今后可能会随我认识的加深而进一步更新。\n本节内容部分参考了以下文章:\n每天都在用 SSH，你知道 SSH 的原理吗？ What Is SSH? How Does SSH Work? SSH为什么要用到DH（Diffie-Hellman Exchange）？ 图文彻底搞懂非对称加密（公钥密钥） 在使用 ssh 访问服务器时，主要经历了以下五个流程:\n1 TCP 握手和协商 该过程又可以划分为以下三个部分:\n建立 TCP 连接：客户端首先向服务器的监听端口（默认是 22 端口）发起 TCP 连接请求，并建立 TCP 三次握手连接（TCP Handshake）。 版本协商：连接建立后，客户端和服务器交换各自支持的 ssh 协议版本信息，并协商出共同支持的最高版本作为后续通信版本。 算法协商：客户端和服务器交换各自支持的加密算法、密钥交换算法、MAC 算法、压缩算法等列表，协商出一组双方都支持且最优的算法套件，用于后续的加密通信、认证和完整性校验等。 2 服务器身份验证 一旦 TCP 连接建立，服务器会首先向客户端发送服务器的公钥/证书，即 host key，以便客户端对服务器进行身份验证（Server Authentication）。\nhost key 是用于验证服务器身份的非对称加密密钥对，包括一组公钥和私钥。host key 用于防止中间人攻击，确保客户端连接的是正确的服务器。这对 host key 会存储在服务端上，其位置为：\n1 2 3 4 # 私钥 /etc/ssh/ssh_host_rsa_key # 公钥 /etc/ssh/ssh_host_rsa_key.pub 在连接时，服务器会发送自己的公钥 ssh_host_rsa_key.pub，这时客户端会进行如下形式的验证：\n若客户端首次连接到该服务器，客户端会收到警告，提示这是一个新的服务器，并询问是否信任该主机，显示类似 The authenticity of host 'xxx' can't be established 的提示。客户端一旦确认没问题，则会将服务器的公钥保存到客户端本地的 ~/.ssh/known_hosts 文件中，以便后续直接连接。 若客户端以前连接过此服务器，客户端会检查收到的公钥是否与 known_hosts 中存储的公钥一致。一致则连接继续；不一致则可能有中间人攻击的风险，客户端会警告并拒绝连接。 如果是使用 ssh CA 签署的 host key，则可以免除此询问过程，客户端会直接信任服务器端。\n由于 ssh 连接是由客户端发起的，所以上述步骤为了让客户端核实服务器是否为客户端要连接的正确服务器，以防止被中间人截胡。\n3 密钥交换 完成服务器身份验证后，客户端会和服务器端使用之前协商好的密钥交换算法（如最常用的 Diffie-Hellman 算法）生成一个共享的会话密钥（Session Key）。该过程即密钥交换（Key Exchange）。\nSession Key 是对称加密密钥，加密和解密速度较快，用于加密接下来会话中的所有数据。此外，Session Key 是临时的，只在当前会话中有效，客户端和服务器同时持有，都使用这个 Session Key 来加密和解密数据。\nSession Key 的生成步骤（Diffie-Hellman 算法）为：\n服务端先生成两个预先约定好的数字 G 和 P。 服务端生成一个临时私钥 b，并使用 G, P 和 b 生成公钥 y。 服务端把 G, P 和 y 直接明文发送给客户端。 客户端生成一个临时私钥 a，并使用接收到的 G, P 与 a 计算出公钥 x。 客户端将公钥 x 发送给服务端。 服务端使用私钥 b 和客户端发来的 x, 以及 P 计算，得到 K。 客户端使用私钥 a 和服务端发来的 y, 以及 P 计算，得到 K。 这里的 K 就是 Session Key。\n为什么服务端和客户端得到的都是 K？\n已知: 客户端 K 的计算公式是 $K = y^a \\bmod P$， 服务端 K 的计算公式是 $K = x^a \\bmod P$,\n而 x 和 y 计算公式是: $y = G^b \\bmod P$， $x = G^a \\bmod P$，\n所以可得: $y^a \\bmod P = (G^b \\bmod P)^a \\bmod P = G^{(b\\times a)} \\bmod P$， $x^b \\bmod P = (G^a \\bmod P)^b \\bmod P = G^{(a\\times b)} \\bmod P$，\n因此二者计算的 K 相同。\n4 用户身份验证 完成密钥交换后，服务端开始验证客户端身份（User Authentication）。\n我们早先在部署一台服务器时，会先在客户端本地生成一对非对称密钥，其中私钥由客户端自己保留，公钥粘贴到服务端的 /home/\u0026lt;user\u0026gt;/.ssh/authorized_keys 里。\n在用户验证阶段，服务端就通过这个公钥来验证客户端。具体而言，客户端会使用私钥将一段数据进行签名，并将签名发送给服务端。服务端使用客户端的 authorized_keys 中的公钥来验证签名，如果验证通过，则认证成功。\n但是在这篇文章中，我看到客户端验证过程可能会更复杂一点 每天都在用 SSH，你知道 SSH 的原理吗？，即多了一个随机挑战内容，而不只是验证签名。大致可划分为这几步：\n客户端发起认证请求：客户端使用自己的私钥对一个数据块进行签名（这个数据块通常包含会话 ID 等信息），并将签名和公钥 ID 发送给服务器。 服务器验证公钥：服务端在 authorized_keys 中找到客户端提供的公钥 ID 对应的公钥，并使用该公钥验证客户端的签名，确认是对应的客户端发起的请求。 服务器发起挑战：服务器会生成一个随机的字符串，称之为挑战，并使用客户端的公钥对字符串进行加密，然后将加密后的挑战发送给客户端。 客户端响应挑战：客户端使用自己的私钥解密服务器挑战，得到原始字符串。然后，为了进一步证明自己是实时客户端而不是重放攻击，客户端还会使用 Session Key 对字符串再加密，并将结果发送给服务器。 服务器验证响应：服务器使用相同的会话密钥对之前生成的挑战值进行加密，并将结果与客户端发送的结果进行比较。若两者一致，则认证通过，允许客户端登录。 挑战-响应机制的优势在于防止重放攻击（Replay Attack），换句话说，即使有人之前窃取了客户端的签名，也无法通过认证，因为每次服务器生成的挑战都是不同的。这样能确保当前进行认证的就是真正的客户端，而不是一个录制下来的认证过程。\n另外，用户身份验证过程一般还可以使用密码验证，不过不安全，一般建议关闭。\n5 建立加密会话 最后，客户端和服务端就会开始用 Session Key 加密通信内容。所有后续的数据传输（命令、文件、输出等）都会使用会话密钥进行加密。\n","permalink":"https://wangzitao21.github.io/zh/ssh-%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/","summary":"\u003cp\u003essh 即 Secure Shell，也就是在 shell 上增加了加密功能。我们常见的 Linux 服务器登录时都使用了 ssh。\u003c/p\u003e\n\u003cp\u003e之前只是糊涂地使用 ssh，并没有搞清楚里面的原理和具体步骤，这次系统地做了一些梳理。\u003c/p\u003e","title":"SSH 协议原理及访问流程"},{"content":"PHREEQC 中密度的计算方式一直让我很困惑，有时候明明输入了一个密度值 A，但是输出密度却是 B。然后把输入的密度改成 B，输出密度又变成了 C。\n最后在 PHREEQC Users 论坛里反复查阅后，基本上搞清楚了密度的计算逻辑。以下是我的总结。\n背景 在 PHREEQC 中，衡量液体质量的单位有两个，一个是 kgw，另一个是 kgs。\n假设只将溶剂视为纯水，那么:\nkgw 指的是 1 kg 纯水。c($x$)=1 mmol/kgw，指的就是一公斤纯水中包含 1 mmol $x$。 kgs 指的是 1 kg 的溶液，里面既包括溶质也包括纯水。c($x$)=1 mmol/kgs，指的就是一公斤溶液 (纯水 + 溶质的质量) 中包含 1 mmol $x$。 当溶液是稀溶液时，溶质的质量可以忽略不计。这种情况下，纯水的密度、黏度等性质就是溶液的性质。\n只有当溶质浓度很高，已经严重影响了溶液的质量时，溶液的质量远大于纯水的质量，密度才会产生较大差异。\n在 PHREEQC 中，会输出 Molality, Activity, Moles 三种结果。其中，Molality 指的是每千克溶剂中溶质的摩尔数，即 mol/kgw；Moles 指的是整个溶液中元素的总摩尔数，即 mol；Activity 指的是离子活度，单位和 Molality 相同。\n密度计算的三种场景 根据输入的单位不同，我将 PHREEQC 的计算逻辑分成三种情况来阐述:\n1 输入单位为 mg/kgw 或 mol/kgw 当我们输入的溶液单位是 mg/kgw 或 mol/kgw 时，输入密度对 PHREEQC 的显示没有任何影响，输入浓度即等于 PHREEQC 最后计算的 Molality。\n比如，我们输入这样一种溶液，使用的数据库是 pitzer.dat:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 SOLUTION 1 -water 1 -temp 25 -units mol/kgw density 1 pH 7 pe 4.0 Ca 0.7 Na 0.889 Mg 0.2 C(4) 0.2 S(6) 0.256 Cl 0.4 END 此时我们不关心离子形态，只看浓度结果:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -----------------------------Solution composition------------------------------ Elements Molality Moles C(4) 2.000e-01 2.000e-01 Ca 7.000e-01 7.000e-01 Cl 4.000e-01 4.000e-01 Mg 2.000e-01 2.000e-01 Na 8.890e-01 8.890e-01 S(6) 2.560e-01 2.560e-01 ----------------------------Description of solution---------------------------- pH = 7.000 pe = 4.000 Density (g/cm3) = 1.09475 Volume (L) = 1.00850 Mass of water (kg) = 1.000e+00 尝试修改输入的密度就会发现，无论输入密度是多少，输出的溶液密度和体积都不会改变。这是因为 PHREEQC 完全没有采用我们的输入密度，它会直接根据溶质的摩尔浓度和摩尔数，自动计算输入溶液的体积和密度。\n如果把上述输入单位从 mol/kgw 改成 mg/kgw，则输出的结果为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -----------------------------Solution composition------------------------------ Elements Molality Moles C(4) 3.278e-06 3.278e-06 Ca 1.747e-05 1.747e-05 Cl 1.128e-05 1.128e-05 Mg 8.229e-06 8.229e-06 Na 3.867e-05 3.867e-05 S(6) 2.665e-06 2.665e-06 ----------------------------Description of solution---------------------------- pH = 7.000 pe = 4.000 Density (g/cm3) = 0.99705 Volume (L) = 1.00297 Mass of water (kg) = 1.000e+00 这时的 Solution composition 部分会被 PHREEQC 自动折算为 mol/kgw，体积和密度也是自动计算的。\n综上所述，如果输入单位为 mg/kgw 或 mol/kgw，PHREEQC 会自己计算密度，此时无论输入的密度是多少都会被忽略。\n2 输入单位为 mg/kgs 或 mol/kgs 当我们输入的溶液单位是 mg/kgs 或 mol/kgs 时，输入密度对 PHREEQC 的显示也没有任何影响，这是因为没有涉及体积的计算。但是此时输入溶质浓度不等于 PHREEQC 最后计算的 Molality，需要进行转换。\n以下述溶液为例，来阐述 PHREEQC 的转换方式:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 SOLUTION 1 -water 1 -temp 25 -units mol/kgs density 1 pH 7 pe 4.0 Ca 0.7 Na 0.889 Mg 0.2 C(4) 0.2 S(6) 0.256 Cl 0.4 END 将上述脚本在 PHREEQC 里运行，得到的结果如下:\n1 2 3 4 5 6 7 Elements Molality Moles C(4) 2.233e-01 2.233e-01 Ca 7.815e-01 7.815e-01 Cl 4.466e-01 4.466e-01 Mg 2.233e-01 2.233e-01 Na 9.926e-01 9.926e-01 S(6) 2.858e-01 2.858e-01 可以看到，PHREEQC 的计算结果比输入的浓度要大。这里的计算逻辑应该是：\n首先将溶质浓度从 mol/kgs 转换为 kg/kgs，并将所有离子求和，得到 1 kgs 的溶液中所有溶质的质量 $\\alpha$ kg。 将 1 kgs 溶液减去 $\\alpha$ kg 得到纯水的质量为 (1-$\\alpha$) kgw。 现在已知 1 kgs 溶液里有多少 mol 的各类离子，用其除以 (1-$\\alpha$) kgw，得到对应的 1 kgw 纯水下的各类离子浓度，即 mol/kgw。 为验证上述逻辑，用 Python 简单计算如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 假设 1 kg 溶液 concentrations = { \u0026#34;Ca\u0026#34;: 0.7, # mol/kgs \u0026#34;Na\u0026#34;: 0.889, \u0026#34;Mg\u0026#34;: 0.2, \u0026#34;Cl\u0026#34;: 0.4, \u0026#34;C(4)\u0026#34;: 0.2, \u0026#34;S(6)\u0026#34;: 0.256, } molar_masses = { \u0026#34;K\u0026#34;: 39.098, # g/mol \u0026#34;Na\u0026#34;: 22.990, \u0026#34;Ca\u0026#34;: 40.078, \u0026#34;Mg\u0026#34;: 24.305, \u0026#34;Li\u0026#34;: 6.94, \u0026#34;Cl\u0026#34;: 35.45, \u0026#34;S(6)\u0026#34;: 96.056, \u0026#34;C(4)\u0026#34;: 60.008 } # 计算各离子质量的总和 total_mass = sum(concentrations[element] * molar_masses[element] for element in concentrations) / 1000 # 1kg 溶液里水的质量为 water_mass = 1 - total_mass ions_mass = {element: concentration / water_mass for element, concentration in concentrations.items()} 输出结果为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 {\u0026#39;Ca\u0026#39;: 0.7813595699827344, \u0026#39;Na\u0026#39;: 0.9923266538780727, \u0026#39;Mg\u0026#39;: 0.22324559142363842, \u0026#39;Cl\u0026#39;: 0.44649118284727685, \u0026#39;C(4)\u0026#39;: 0.22324559142363842, \u0026#39;S(6)\u0026#39;: 0.28575435702225715} {\u0026#39;Ca\u0026#39;: 0.7814, \u0026#39;Na\u0026#39;: 0.9923, \u0026#39;Mg\u0026#39;: 0.2232, \u0026#39;Cl\u0026#39;: 0.4465, \u0026#39;C(4)\u0026#39;: 0.2232, \u0026#39;S(6)\u0026#39;: 0.2858} 此时基本上和 PHREEQC 计算结果无异，至于为什么每个离子都会有 0.0001-0.0003 的偏差，我猜可能和摩尔质量的四舍五入，以及数据库的选择有关系。\n3 输入单位为 mg/L 或 mol/L 在实际工作中，最常用的还是 mol/L 或 mg/L 这样的单位。但这种情况在 PHREEQC 里最为复杂，因为此时我们输入的密度值起作用了。\n正如前面所说，由于 phreeqc.dat 和 pitzer.dat 等数据库对溶液组分有摩尔体积的定义，PHREEQC 可以自动计算密度。但 PHREEQC 内部计算密度的过程较为复杂，在此不做过多讨论，我们仅分析当输入密度值时，输出结果是如何转换的。\n将输入的 density 认作输入密度，PHREEQC 计算的密度认作计算密度。\n这里的密度指的是溶液的密度，不可能是纯水的密度，讨论纯水的密度没有意义。PHREEQC 输入的密度和计算密度也都是溶液密度。\n还是以前一节的案例为例，只是把浓度单位改成 mol/L，密度设为 1.2 kgs/m$^3$:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 SOLUTION 1 -water 1 -temp 25 -units mol/L density 1.2 pH 7 pe 4.0 Ca 0.7 Na 0.889 Mg 0.2 C(4) 0.2 S(6) 0.256 Cl 0.4 END 我在论坛的这个帖子 Density calculation and mole concentration of components 和 Converting from molality (mol/kgw) to mg/l for high solubility minerals 里看到 PHREEQC 开发者说了这样一句话:\nDensity is used to convert mg/L to mg/kgs. Then, the sum of the solutes is subtracted from the kilogram of solution to get the mass of water. Finally, the masses are scaled to produce 1 kg of water.\n他的意思是，我们的输入密度只用于将输入单位从 xx/L 转换为 xx/kgs。然后再遵照我们在前一节讨论的那样，将单位再转换为 xx/kgw，也就是缩放成 1 kg 水时的摩尔浓度。\n这说明输入密度只起一个初始转换作用，PHREEQC 还是会自己计算密度的。此时的步骤应该是:\n将输入的离子浓度 mol/L 除以输入的密度 kg/m$^3$，约去体积，得到 mol/kgs。 遵照上一节计算步骤，得到 1 kgw 纯水下的各类离子浓度，即 mol/kgw。 验证的 Python 脚本如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 concentrations = { \u0026#34;Ca\u0026#34;: 0.7 / 1.2, # mol/L / density kg/m^3 \u0026#34;Na\u0026#34;: 0.889 / 1.2, \u0026#34;Mg\u0026#34;: 0.2 / 1.2, \u0026#34;Cl\u0026#34;: 0.4 / 1.2, \u0026#34;C(4)\u0026#34;: 0.2 / 1.2, \u0026#34;S(6)\u0026#34;: 0.256 / 1.2, } molar_masses = { \u0026#34;K\u0026#34;: 39.098, # g/mol \u0026#34;Na\u0026#34;: 22.990, \u0026#34;Ca\u0026#34;: 40.078, \u0026#34;Mg\u0026#34;: 24.305, \u0026#34;Li\u0026#34;: 6.94, \u0026#34;Cl\u0026#34;: 35.45, \u0026#34;S(6)\u0026#34;: 96.056, \u0026#34;C(4)\u0026#34;: 60.008 } total_mass = sum(concentrations[element] * molar_masses[element] for element in concentrations) / 1000 water_mass = 1 - total_mass normalized_ions_mass = {element: concentration / water_mass for element, concentration in concentrations.items()} normalized_ions_mass 输出结果为:\n1 2 3 4 5 6 \u0026#39;Ca\u0026#39;: 0.6387593590861604, \u0026#39;Na\u0026#39;: 0.8112243860394237, \u0026#39;Mg\u0026#39;: 0.18250267402461728, \u0026#39;Cl\u0026#39;: 0.36500534804923457, \u0026#39;C(4)\u0026#39;: 0.18250267402461728, \u0026#39;S(6)\u0026#39;: 0.23360342275151008 PHREEQC 的结果为:\n1 2 3 4 5 6 7 Elements Molality Moles C(4) 1.825e-01 1.825e-01 Ca 6.389e-01 6.389e-01 Cl 3.651e-01 3.651e-01 Mg 1.825e-01 1.825e-01 Na 8.114e-01 8.114e-01 S(6) 2.336e-01 2.336e-01 还是会有极小的差异，理由同上。\n关于 PHREEQC 中的 calc 参数 在 PHREEQC 的 3.8 以上版本里，如果在密度后面加上一个 calc，那么 PHREEQC 的密度计算会迭代倾向于输入的密度。\n但是这个效果我没测试出来，不敢确定。\n具体可见:\nDensity calculation in the Description of solution section of the output Versions 3.8.2 of all PHREEQC programs have been released。 PHREEQC 中的体积 PHREEQC 里输出的体积是根据其内在逻辑 (包括离子的摩尔体积等参数) 自己算的，和我们的密度无关。\n在 SOLUTION 关键字中，会输入一个 -water 参数。这个 -water 指的是定义的纯水质量，而且根据前面密度和浓度的计算逻辑就可以知道，这个参数不会影响 Molality 的结果，只会影响 Moles。\n例如，还是以上述案例为例，将 -water 分别增大 10 倍和 100 倍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 SOLUTION 1 -water 10 -temp 25 -units mol/kgw density 2 pH 7 pe 4.0 Ca 0.7 Na 0.889 Mg 0.2 C(4) 0.2 S(6) 0.256 Cl 0.4 END 此时计算的结果为:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # -water 10 Elements Molality Moles C(4) 2.000e-01 2.000e+00 Ca 7.000e-01 7.000e+00 Cl 4.000e-01 4.000e+00 Mg 2.000e-01 2.000e+00 Na 8.890e-01 8.890e+00 S(6) 2.560e-01 2.560e+00 Density (g/cm3) = 1.09475 Volume (L) = 10.08496 # -water 100 Elements Molality Moles C(4) 2.000e-01 2.000e+01 Ca 7.000e-01 7.000e+01 Cl 4.000e-01 4.000e+01 Mg 2.000e-01 2.000e+01 Na 8.890e-01 8.890e+01 S(6) 2.560e-01 2.560e+01 Density (g/cm3) = 1.09475 Volume (L) = 100.84961 可以看到只有 Moles 在增加，对 Molality 无影响。体积也随着质量同比增大。\n由此可知，在 PHREEQC 里，我们不能自由的控制体积输入，PHREEQC 会根据需求自动计算密度和体积。但是随着纯水的质量 -water 增多，体积也随之增加。\n在反应运移过程中，是不能随便将 mol/L 作为输入的。如果非要指定溶液体积，一定要输入 mol/L，则需要按以下情况分别处理:\n假设已知某次计算的溶液体积是 $m$ L。如果是稀溶液，那就当成 $m$ L 纯水，这时候直接输入 -water 0.001*m kgw 就可以了。 如果是浓溶液，则需要确保自己测量出准确的溶液密度，然后将 $m$ L 溶液折算成 $kgs$。在此基础上，减去溶质的质量，得到纯水的质量 kgw，赋给 -water，才能确保 PHREEQC 计算的 Moles 符合预期。 输出结果转换为 mol/L PHREEQC 的输出默认都是 mol/kgw，而且没有可选单位。\n如果非要转换为 mol/L，则可以使用 PUNCH 关键字，例如:\n1 10 PUNCH TOT(\u0026#34;K\u0026#34;) * TOT(\u0026#34;water\u0026#34;) / SOLN_VOL 其中 TOT 指的是离子的 Molality，单位 mol/kgw，TOT(\u0026quot;water\u0026quot;) 特指纯水的质量，kgw。SOLN_VOL 是溶液的体积，由 PHREEQC 计算所得。\n","permalink":"https://wangzitao21.github.io/zh/phreeqc-%E4%B8%AD%E5%AF%86%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E9%80%BB%E8%BE%91/","summary":"\u003cp\u003ePHREEQC 中密度的计算方式一直让我很困惑，有时候明明输入了一个密度值 A，但是输出密度却是 B。然后把输入的密度改成 B，输出密度又变成了 C。\u003c/p\u003e\n\u003cp\u003e最后在 \u003ca href=\"https://www.phreeqcusers.org/\"\u003ePHREEQC Users\u003c/a\u003e 论坛里反复查阅后，基本上搞清楚了密度的计算逻辑。以下是我的总结。\u003c/p\u003e","title":"PHREEQC 中密度的计算逻辑"},{"content":"这是我搭建的一个 $f_{ESI}$ 博客。\n$$\n\\text{Max } f_{NAB} = \\sum_{p=1}^P\\sum_{s=1}^S PC_{p,s}Y_{p,s}A_{p,s} - \\sum_{p=1}^P\\sum_{s=1}^S CC_{p,s}A_{p,s} $$\n","permalink":"https://wangzitao21.github.io/zh/about/","summary":"\u003cp\u003e这是我搭建的一个 $f_{ESI}$ 博客。\u003c/p\u003e\n\u003cp\u003e$$\u003cbr\u003e\n\\text{Max } f_{NAB} = \\sum_{p=1}^P\\sum_{s=1}^S PC_{p,s}Y_{p,s}A_{p,s} - \\sum_{p=1}^P\\sum_{s=1}^S CC_{p,s}A_{p,s}\n$$\u003c/p\u003e","title":"关于"},{"content":"在 Windows 系统中，有时添加一些可执行文件的环境变量，如 ffmpeg、modflow 等，通常需要重启系统才能生效。\n然而重启往往需要关闭许多正在进行的任务，很麻烦。\n以下步骤可以在不重启系统的情况下刷新环境变量：\n将需要添加的程序的路径添加到环境变量中。 打开 CMD，输入 echo %Path% 查看当前的环境变量。 输入 set PATH=C:。 关闭 CMD 并重新打开，再次输入 echo %Path% 会发现环境变量已更新。 ","permalink":"https://wangzitao21.github.io/zh/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E9%87%8D%E5%90%AF-windows-%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%B7%E6%96%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","summary":"\u003cp\u003e在 Windows 系统中，有时添加一些可执行文件的环境变量，如 ffmpeg、modflow 等，通常需要重启系统才能生效。\u003c/p\u003e\n\u003cp\u003e然而重启往往需要关闭许多正在进行的任务，很麻烦。\u003c/p\u003e","title":"如何在不重启 Windows 系统的情况下刷新环境变量"}]