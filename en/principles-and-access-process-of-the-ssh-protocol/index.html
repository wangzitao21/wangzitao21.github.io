<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Principles and Access Process of the SSH Protocol | Wang's Blog</title><meta name=keywords content="Linux"><meta name=description content="SSH stands for Secure Shell, which adds encryption to the shell. The common Linux server logins we encounter use SSH.
Previously, I used SSH without a clear understanding of its principles and specific steps. This time, I have systematically organized some information.
However, this article is still relatively basic and may be further updated as my understanding deepens.
Parts of this section refer to the following articles:

You use SSH every day, but do you know its principles?
What Is SSH? How Does SSH Work?
Why does SSH need to use DH (Diffie-Hellman Exchange)?
A thorough explanation of asymmetric encryption (public and private keys) with illustrations

When using SSH to access a server, the following five processes are mainly involved:"><meta name=author content="Zitao Wang"><link rel=canonical href=https://wangzitao21.github.io/en/principles-and-access-process-of-the-ssh-protocol/><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"}),MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}})</script><link crossorigin=anonymous href=/assets/css/stylesheet.fd8148162c37b6c614040ca84c7e23ff1f4345bbfc886131f171350edd32073f.css integrity="sha256-/YFIFiw3tsYUBAyoTH4j/x9DRbv8iGEx8XE1Dt0yBz8=" rel="preload stylesheet" as=style><link rel=icon href=https://wangzitao21.github.io/favicon/favicon16x16.gif><link rel=icon type=image/png sizes=16x16 href=https://wangzitao21.github.io/favicon/favicon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wangzitao21.github.io/favicon/favicon32x32.png><link rel=apple-touch-icon href=https://wangzitao21.github.io/favicon/favicon180x180.png><link rel=mask-icon href=https://wangzitao21.github.io/favicon/favicon180x180.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wangzitao21.github.io/en/principles-and-access-process-of-the-ssh-protocol/><link rel=alternate hreflang=zh href=https://wangzitao21.github.io/zh/ssh-%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wangzitao21.github.io/en/principles-and-access-process-of-the-ssh-protocol/"><meta property="og:site_name" content="Wang's Blog"><meta property="og:title" content="Principles and Access Process of the SSH Protocol"><meta property="og:description" content="SSH stands for Secure Shell, which adds encryption to the shell. The common Linux server logins we encounter use SSH.
Previously, I used SSH without a clear understanding of its principles and specific steps. This time, I have systematically organized some information.
However, this article is still relatively basic and may be further updated as my understanding deepens.
Parts of this section refer to the following articles:
You use SSH every day, but do you know its principles? What Is SSH? How Does SSH Work? Why does SSH need to use DH (Diffie-Hellman Exchange)? A thorough explanation of asymmetric encryption (public and private keys) with illustrations When using SSH to access a server, the following five processes are mainly involved:"><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-01-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-25T00:00:00+00:00"><meta property="article:tag" content="Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="Principles and Access Process of the SSH Protocol"><meta name=twitter:description content="SSH stands for Secure Shell, which adds encryption to the shell. The common Linux server logins we encounter use SSH.
Previously, I used SSH without a clear understanding of its principles and specific steps. This time, I have systematically organized some information.
However, this article is still relatively basic and may be further updated as my understanding deepens.
Parts of this section refer to the following articles:

You use SSH every day, but do you know its principles?
What Is SSH? How Does SSH Work?
Why does SSH need to use DH (Diffie-Hellman Exchange)?
A thorough explanation of asymmetric encryption (public and private keys) with illustrations

When using SSH to access a server, the following five processes are mainly involved:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wangzitao21.github.io/en/post/"},{"@type":"ListItem","position":2,"name":"Principles and Access Process of the SSH Protocol","item":"https://wangzitao21.github.io/en/principles-and-access-process-of-the-ssh-protocol/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Principles and Access Process of the SSH Protocol","name":"Principles and Access Process of the SSH Protocol","description":"SSH stands for Secure Shell, which adds encryption to the shell. The common Linux server logins we encounter use SSH.\nPreviously, I used SSH without a clear understanding of its principles and specific steps. This time, I have systematically organized some information.\nHowever, this article is still relatively basic and may be further updated as my understanding deepens.\nParts of this section refer to the following articles:\nYou use SSH every day, but do you know its principles? What Is SSH? How Does SSH Work? Why does SSH need to use DH (Diffie-Hellman Exchange)? A thorough explanation of asymmetric encryption (public and private keys) with illustrations When using SSH to access a server, the following five processes are mainly involved:\n","keywords":["Linux"],"articleBody":"SSH stands for Secure Shell, which adds encryption to the shell. The common Linux server logins we encounter use SSH.\nPreviously, I used SSH without a clear understanding of its principles and specific steps. This time, I have systematically organized some information.\nHowever, this article is still relatively basic and may be further updated as my understanding deepens.\nParts of this section refer to the following articles:\nYou use SSH every day, but do you know its principles? What Is SSH? How Does SSH Work? Why does SSH need to use DH (Diffie-Hellman Exchange)? A thorough explanation of asymmetric encryption (public and private keys) with illustrations When using SSH to access a server, the following five processes are mainly involved:\n1 TCP Handshake and Negotiation This process can be further divided into the following three parts:\nEstablish TCP Connection: The client first initiates a TCP connection request to the server’s listening port (default is port 22) and establishes a TCP three-way handshake connection (TCP Handshake). Version Negotiation: After the connection is established, the client and server exchange their respective supported SSH protocol version information and negotiate the highest commonly supported version as the subsequent communication version. Algorithm Negotiation: The client and server exchange their respective supported lists of encryption algorithms, key exchange algorithms, MAC algorithms, compression algorithms, etc., and negotiate a set of algorithm suites that are both supported and optimal, used for subsequent encrypted communication, authentication, and integrity verification. 2 Server Authentication Once the TCP connection is established, the server first sends its public key/certificate, i.e., the host key, to the client for server authentication.\nThe host key is an asymmetric encryption key pair used to verify the server’s identity, including a public key and a private key. The host key is used to prevent man-in-the-middle attacks, ensuring that the client is connected to the correct server. This pair of host keys is stored on the server, and their locations are:\n1 2 3 4 # Private key /etc/ssh/ssh_host_rsa_key # Public key /etc/ssh/ssh_host_rsa_key.pub During the connection, the server sends its public key ssh_host_rsa_key.pub. At this point, the client performs verification in the following ways:\nIf the client is connecting to the server for the first time, the client will receive a warning indicating that this is a new server and asking whether to trust this host, displaying a message like The authenticity of host 'xxx' can't be established. Once the client confirms, it will save the server’s public key to the local ~/.ssh/known_hosts file for direct connection in the future. If the client has previously connected to this server, the client checks whether the received public key matches the public key stored in known_hosts. If they match, the connection continues; if they do not match, there may be a risk of a man-in-the-middle attack, and the client will warn and refuse the connection. If a host key signed by an SSH CA is used, this inquiry process can be avoided, and the client will directly trust the server.\nSince the SSH connection is initiated by the client, the above steps are to allow the client to verify that the server is the correct server to be connected to, in order to prevent being intercepted by a man-in-the-middle.\n3 Key Exchange After completing server authentication, the client and server use the previously negotiated key exchange algorithm (such as the most commonly used Diffie-Hellman algorithm) to generate a shared Session Key. This process is the Key Exchange.\nThe Session Key is a symmetric encryption key, which is faster for encryption and decryption, and is used to encrypt all data in the subsequent session. In addition, the Session Key is temporary, only valid during the current session, and both the client and server hold it, using it to encrypt and decrypt data.\nThe steps to generate the Session Key (Diffie-Hellman algorithm) are:\nThe server first generates two pre-agreed numbers, G and P. The server generates a temporary private key b and uses G, P, and b to generate a public key y. The server sends G, P, and y directly to the client in plain text. The client generates a temporary private key a and uses the received G, P, and a to calculate a public key x. The client sends the public key x to the server. The server uses the private key b, the received x, and P to calculate K. The client uses the private key a, the received y, and P to calculate K. Here, K is the Session Key.\nWhy do both the server and the client get K?\nGiven:\nThe client’s calculation formula for K is $K = y^a \\bmod P$, The server’s calculation formula for K is $K = x^b \\bmod P$,\nAnd the calculation formulas for x and y are:\n$y = G^b \\bmod P$, $x = G^a \\bmod P$,\nTherefore, we can derive:\n$y^a \\bmod P = (G^b \\bmod P)^a \\bmod P = G^{(b\\times a)} \\bmod P$,\n$x^b \\bmod P = (G^a \\bmod P)^b \\bmod P = G^{(a\\times b)} \\bmod P$,\nThus, both calculate the same K.\n4 User Authentication After the key exchange is completed, the server begins to verify the client’s identity (User Authentication).\nEarlier, when deploying a server, we would first generate a pair of asymmetric keys on the client-side, where the private key is kept by the client, and the public key is pasted into /home//.ssh/authorized_keys on the server.\nDuring the user authentication phase, the server uses this public key to verify the client. Specifically, the client uses the private key to sign a piece of data and sends the signature to the server. The server uses the client’s public key from authorized_keys to verify the signature. If the verification is successful, the authentication is successful.\nHowever, in this article, I saw that the client verification process might be a bit more complex You use SSH every day, but do you know its principles?, involving an additional random challenge rather than just verifying the signature. It can be roughly divided into these steps:\nClient Initiates Authentication Request: The client uses its private key to sign a data block (this data block usually contains information such as the session ID) and sends the signature and public key ID to the server. Server Verifies Public Key: The server finds the public key corresponding to the public key ID provided by the client in authorized_keys and uses this public key to verify the client’s signature, confirming that the request was initiated by the corresponding client. Server Issues Challenge: The server generates a random string, called a challenge, encrypts it using the client’s public key, and then sends the encrypted challenge to the client. Client Responds to Challenge: The client uses its private key to decrypt the server’s challenge, obtaining the original string. Then, to further prove that it is a real-time client and not a replay attack, the client also uses the Session Key to encrypt the string again and sends the result to the server. Server Verifies Response: The server uses the same session key to encrypt the previously generated challenge value and compares the result with the result sent by the client. If the two are consistent, authentication is successful, and the client is allowed to log in. The advantage of the challenge-response mechanism is to prevent Replay Attacks. In other words, even if someone previously stole the client’s signature, they cannot pass authentication because the challenge generated by the server is different each time. This ensures that the entity currently undergoing authentication is the real client and not a recorded authentication process.\nAdditionally, user authentication can generally also use password authentication, but it is not secure and is generally recommended to be turned off.\n5 Establishing an Encrypted Session Finally, the client and server will start using the Session Key to encrypt the communication content. All subsequent data transmission (commands, files, output, etc.) will be encrypted using the session key.\n","wordCount":"1321","inLanguage":"en","datePublished":"2025-01-25T00:00:00Z","dateModified":"2025-01-25T00:00:00Z","author":{"@type":"Person","name":"Zitao Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wangzitao21.github.io/en/principles-and-access-process-of-the-ssh-protocol/"},"publisher":{"@type":"Organization","name":"Wang's Blog","logo":{"@type":"ImageObject","url":"https://wangzitao21.github.io/favicon/favicon16x16.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangzitao21.github.io/en/ accesskey=h title="Wang's Blog (Alt + H)">Wang's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wangzitao21.github.io/zh/ title="🌐 切换为中文" aria-label="🌐 切换为中文">🌐 切换为中文</a></li></ul></div></div><ul id=menu><li><a href=https://wangzitao21.github.io/en/ title=🏠Home><span>🏠Home</span></a></li><li><a href=https://wangzitao21.github.io/en/search title="🔎Search (Alt + /)" accesskey=/><span>🔎Search</span></a></li><li><a href=https://wangzitao21.github.io/en/archives title=📚Archives><span>📚Archives</span></a></li><li><a href=https://wangzitao21.github.io/en/tags title=🧩️Tags><span>🧩️Tags</span></a></li><li><a href=https://wangzitao21.github.io/en/about title=👤About><span>👤About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wangzitao21.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://wangzitao21.github.io/en/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Principles and Access Process of the SSH Protocol</h1><div class=post-meta><span title='2025-01-25 00:00:00 +0000 UTC'>1/25/2025</span>&nbsp;·&nbsp;Zitao Wang&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://wangzitao21.github.io/zh/ssh-%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/>🌐 切换为中文</a></li></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-tcp-handshake-and-negotiation aria-label="1 TCP Handshake and Negotiation">1 TCP Handshake and Negotiation</a></li><li><a href=#2-server-authentication aria-label="2 Server Authentication">2 Server Authentication</a></li><li><a href=#3-key-exchange aria-label="3 Key Exchange">3 Key Exchange</a></li><li><a href=#4-user-authentication aria-label="4 User Authentication">4 User Authentication</a></li><li><a href=#5-establishing-an-encrypted-session aria-label="5 Establishing an Encrypted Session">5 Establishing an Encrypted Session</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>SSH stands for Secure Shell, which adds encryption to the shell. The common Linux server logins we encounter use SSH.</p><p>Previously, I used SSH without a clear understanding of its principles and specific steps. This time, I have systematically organized some information.</p><p>However, this article is still relatively basic and may be further updated as my understanding deepens.</p><p>Parts of this section refer to the following articles:</p><ul><li><a href=https://zhuanlan.zhihu.com/p/108161141>You use SSH every day, but do you know its principles?</a></li><li><a href=https://info.support.huawei.com/info-finder/encyclopedia/en/SSH.html>What Is SSH? How Does SSH Work?</a></li><li><a href=https://www.zhihu.com/question/282877403>Why does SSH need to use DH (Diffie-Hellman Exchange)?</a></li><li><a href=https://zhuanlan.zhihu.com/p/436455172>A thorough explanation of asymmetric encryption (public and private keys) with illustrations</a></li></ul><p>When using SSH to access a server, the following five processes are mainly involved:</p><h1 id=1-tcp-handshake-and-negotiation>1 TCP Handshake and Negotiation<a hidden class=anchor aria-hidden=true href=#1-tcp-handshake-and-negotiation>#</a></h1><p>This process can be further divided into the following three parts:</p><ol><li>Establish TCP Connection: The client first initiates a TCP connection request to the server&rsquo;s listening port (default is port 22) and establishes a TCP three-way handshake connection (TCP Handshake).</li><li>Version Negotiation: After the connection is established, the client and server exchange their respective supported SSH protocol version information and negotiate the highest commonly supported version as the subsequent communication version.</li><li>Algorithm Negotiation: The client and server exchange their respective supported lists of encryption algorithms, key exchange algorithms, MAC algorithms, compression algorithms, etc., and negotiate a set of algorithm suites that are both supported and optimal, used for subsequent encrypted communication, authentication, and integrity verification.</li></ol><h1 id=2-server-authentication>2 Server Authentication<a hidden class=anchor aria-hidden=true href=#2-server-authentication>#</a></h1><p>Once the TCP connection is established, the server first sends its public key/certificate, i.e., the host key, to the client for server authentication.</p><p>The host key is an asymmetric encryption key pair used to verify the server&rsquo;s identity, including a public key and a private key. The host key is used to prevent man-in-the-middle attacks, ensuring that the client is connected to the correct server. This pair of host keys is stored on the server, and their locations are:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Private key</span>
</span></span><span class=line><span class=cl>/etc/ssh/ssh_host_rsa_key
</span></span><span class=line><span class=cl><span class=c1># Public key</span>
</span></span><span class=line><span class=cl>/etc/ssh/ssh_host_rsa_key.pub
</span></span></code></pre></td></tr></table></div></div><p>During the connection, the server sends its public key <code>ssh_host_rsa_key.pub</code>. At this point, the client performs verification in the following ways:</p><ul><li>If the client is connecting to the server for the first time, the client will receive a warning indicating that this is a new server and asking whether to trust this host, displaying a message like <code>The authenticity of host 'xxx' can't be established</code>. Once the client confirms, it will save the server&rsquo;s public key to the local <code>~/.ssh/known_hosts</code> file for direct connection in the future.</li><li>If the client has previously connected to this server, the client checks whether the received public key matches the public key stored in <code>known_hosts</code>. If they match, the connection continues; if they do not match, there may be a risk of a man-in-the-middle attack, and the client will warn and refuse the connection.</li></ul><blockquote><p>If a host key signed by an SSH CA is used, this inquiry process can be avoided, and the client will directly trust the server.</p></blockquote><p>Since the SSH connection is initiated by the client, the above steps are to allow the client to verify that the server is the correct server to be connected to, in order to prevent being intercepted by a man-in-the-middle.</p><h1 id=3-key-exchange>3 Key Exchange<a hidden class=anchor aria-hidden=true href=#3-key-exchange>#</a></h1><p>After completing server authentication, the client and server use the previously negotiated key exchange algorithm (such as the most commonly used Diffie-Hellman algorithm) to generate a shared Session Key. This process is the Key Exchange.</p><p>The Session Key is a symmetric encryption key, which is faster for encryption and decryption, and is used to encrypt all data in the subsequent session. In addition, the Session Key is temporary, only valid during the current session, and both the client and server hold it, using it to encrypt and decrypt data.</p><p>The steps to generate the Session Key (Diffie-Hellman algorithm) are:</p><ol><li>The server first generates two pre-agreed numbers, G and P.</li><li>The server generates a temporary private key b and uses G, P, and b to generate a public key y.</li><li>The server sends G, P, and y directly to the client in plain text.</li><li>The client generates a temporary private key a and uses the received G, P, and a to calculate a public key x.</li><li>The client sends the public key x to the server.</li><li>The server uses the private key b, the received x, and P to calculate K.</li><li>The client uses the private key a, the received y, and P to calculate K.</li></ol><p>Here, K is the Session Key.</p><blockquote><p>Why do both the server and the client get K?</p><p>Given:</p><p>The client&rsquo;s calculation formula for K is $K = y^a \bmod P$,
The server&rsquo;s calculation formula for K is $K = x^b \bmod P$,</p><p>And the calculation formulas for x and y are:</p><p>$y = G^b \bmod P$,
$x = G^a \bmod P$,</p><p>Therefore, we can derive:</p><p>$y^a \bmod P = (G^b \bmod P)^a \bmod P = G^{(b\times a)} \bmod P$,</p><p>$x^b \bmod P = (G^a \bmod P)^b \bmod P = G^{(a\times b)} \bmod P$,</p><p>Thus, both calculate the same K.</p></blockquote><h1 id=4-user-authentication>4 User Authentication<a hidden class=anchor aria-hidden=true href=#4-user-authentication>#</a></h1><p>After the key exchange is completed, the server begins to verify the client&rsquo;s identity (User Authentication).</p><p>Earlier, when deploying a server, we would first generate a pair of asymmetric keys on the client-side, where the private key is kept by the client, and the public key is pasted into <code>/home/&lt;user>/.ssh/authorized_keys</code> on the server.</p><p>During the user authentication phase, the server uses this public key to verify the client. Specifically, the client uses the private key to sign a piece of data and sends the signature to the server. The server uses the client&rsquo;s public key from <code>authorized_keys</code> to verify the signature. If the verification is successful, the authentication is successful.</p><p>However, in this article, I saw that the client verification process might be a bit more complex <a href=https://zhuanlan.zhihu.com/p/108161141>You use SSH every day, but do you know its principles?</a>, involving an additional random challenge rather than just verifying the signature. It can be roughly divided into these steps:</p><ol><li><strong>Client Initiates Authentication Request</strong>: The client uses its private key to sign a data block (this data block usually contains information such as the session ID) and sends the signature and public key ID to the server.</li><li><strong>Server Verifies Public Key</strong>: The server finds the public key corresponding to the public key ID provided by the client in <code>authorized_keys</code> and uses this public key to verify the client&rsquo;s signature, confirming that the request was initiated by the corresponding client.</li><li><strong>Server Issues Challenge</strong>: The server generates a random string, called a challenge, encrypts it using the client&rsquo;s public key, and then sends the encrypted challenge to the client.</li><li><strong>Client Responds to Challenge</strong>: The client uses its private key to decrypt the server&rsquo;s challenge, obtaining the original string. Then, to further prove that it is a real-time client and not a replay attack, the client also uses the Session Key to encrypt the string again and sends the result to the server.</li><li><strong>Server Verifies Response</strong>: The server uses the same session key to encrypt the previously generated challenge value and compares the result with the result sent by the client. If the two are consistent, authentication is successful, and the client is allowed to log in.</li></ol><p>The advantage of the challenge-response mechanism is to prevent Replay Attacks. In other words, even if someone previously stole the client&rsquo;s signature, they cannot pass authentication because the challenge generated by the server is different each time. This ensures that the entity currently undergoing authentication is the real client and not a recorded authentication process.</p><blockquote><p>Additionally, user authentication can generally also use password authentication, but it is not secure and is generally recommended to be turned off.</p></blockquote><h1 id=5-establishing-an-encrypted-session>5 Establishing an Encrypted Session<a hidden class=anchor aria-hidden=true href=#5-establishing-an-encrypted-session>#</a></h1><p>Finally, the client and server will start using the Session Key to encrypt the communication content. All subsequent data transmission (commands, files, output, etc.) will be encrypted using the session key.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wangzitao21.github.io/en/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://wangzitao21.github.io/en/methods-to-access-dynamic-public-ipv6/><span class=title>« Prev</span><br><span>Methods to Access Dynamic Public IPv6</span>
</a><a class=next href=https://wangzitao21.github.io/en/calculation-logic-of-density-in-phreeqc/><span class=title>Next »</span><br><span>Calculation Logic of Density in PHREEQC</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=wangzitao21/wangzitao21.github.io data-repo-id=R_kgDONoUNzQ data-category=Announcements data-category-id=DIC_kwDONoUNzc4Cl6-6 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>